#! Streams and stream combinators.
#!
#! In other languages, streams are often called 'iterators'.

import "value.tao"

class Stream A, e =
    => next : Self -> Maybe (e ~ A, Self)

for A, e member Range A of Stream A e where
    A < Ord + Add A with { Output = A } + One
=
    => next = fn Range (from, to) => if from >= to
        then None
        else
            let one : A = one in # TODO: This line is silly, figure out why we can't infer this
            Just (effect { from }, Range (from + one, to))

data Stream S = S

data Mapped S, A, B, e, f = ((e ~ A) -> f ~ B, S)

for S < Stream A e, A, B, e member Mapped S A B e e of Stream B e =
    => next = fn Mapped (f, s) => when s->S.next is
        | None => None
        \ Just (x, s) => Just (x->f, Mapped (f, s))

for S, A, B, e, f member Stream S of Map (e ~ A) B f where
    S < Stream A e
=
    => Output = Stream (Mapped S A B e f)
    => map = fn f, Stream s => Stream Mapped (f, s)

# fn collect2 S, A, e : Stream S -> e ~ [A] where
#     S < Stream e ~ A
# = Stream s => when S.next(s) is
#     | None => []
#     \ Just (x, s) => [x!] ++ (Stream s)->collect2!

class ToStream A, e where
    Self.Stream < Stream A e
=
    => Stream
    => to_stream : Self -> Self.Stream

for A, e member [e ~ A] of ToStream A e =
    => Stream = [e ~ A]
    => to_stream = fn xs => xs

for A, e member Maybe e ~ A of Stream A e =
    => next = fn
        | None => None
        \ Just x => Just (x, None)

for A, e member [e ~ A] of Stream A e =
    => next = fn
        | [] => None
        \ [x .. xs] => Just (x, xs)

class FromStream A =
    => from_stream : [A] -> Self

for A member [A] of FromStream A =
    => from_stream = fn xs => xs

for A member Maybe A of FromStream A =
    => from_stream = fn
        | [] => None
        \ [x ..] => Just x

$[util]
fn collect S < Stream A e, A, B < FromStream A, e : Stream S -> e ~ B =
    Stream s => let xs = s->fix(fn rec, s => when s->S.next is
        | None => []
        \ Just (x, s) => [x! .. rec(s)!])! in xs->B.from_stream

data Range A = (A, A)

$[util]
fn range A : A -> A -> Stream (Range A) = from, to => Stream Range (from, to)
